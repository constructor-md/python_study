# coding=utf-8

print("你好，世界")

# Python3 将python2中的input()删除了，同时将raw_input()改名为input()
'''
    python3 input()输入时数据最后都会输出成字符串格式
    如果进行数据格式输入，需要利用int()做格式转换
    
    1.输错类型会在类型转换时报错（正常）
    2.空串非法
'''
# inputNum = input("请利用键盘输入数字： 回车后结束\n")
# print(inputNum)
# print(int(inputNum))
#
# inputStr = input("请利用键盘输入字符串： 回车后结束\n")
# print(int(inputStr))
# print(inputStr)
#
# str1 = "输入1"
# str2 = "输入2"
# print(str1)

'''
    字符串截取包头不包尾
    正序截取从0开始
    倒序截取末尾从-1开始
    及时从倒序截取，头也是在左边，尾在右边的包头不包尾

'''
str3 = "abcdefg"
print(str3[0])
print(str3[1:])
print(str3[2:3])
print(str3[: -2])

'''
    python的五大基本数据类型

    数字 Numbers
    字符串 String
    列表 List
    元组 Tuple 
    字典 Dictionary

'''

# 数字 支持四种数字类型
var1 = 100  # 整型

'''
    一些发现和查询信息
    变量定义时没有写明变量类型，这是因为python的设计思想中的：引用和对象分离（动态类型 -- python的核心机制和特性）
    python的变量不需要声明，运行过程中，引用可以指向任意类型的对象（不清楚这里的指向是否导致并发问题，或是复制对象）
    该引用的数据类型和内存分配问题都是在运行时决定
    
    和java不一样，python的引用甚至没有类型信息，如果存在非法的数据操作，所有的异常都会在运行中报出
    对于实参和返回值，需要开发者自行review或debug或作合适的业务处理，增加开发成本
    
    python3.6开始加入了数据类型检查功能，借助IDE的高亮提示，在调用函数或方法时传递了错误的数据类型或返回值数据类型，会高亮
    可以用 g: int的形式提示参数类型 方法 -> int 的形式提示返回值类型
    但是并没有严格的限制使用规则，只是在做提醒，也只有提示功能，解释型语言不存在编译，所以也没有编译期检查一说。。 
    毕竟在无类型信息的世界，对于外界输入的各种可能性变量总是不太安全
    
    python和java的垃圾收集
    
    python内存管理： 
        1.引用计数，如果引用计数为0则该对象内存空间被gc回收
        补充：
        引用计数（x的引用计数）增加的情况：
　           １）对象被创建，比如  x = 4
　           ２）一个新引用指向了对象引用， y = x
　           ３）作为参数传递给函数，fun(x)
　           ４）作为容器对象的一个元素，a=[1,x,3]

        引用计数（x的引用计数）增加的情况：
　           １）一个本地引用离开它的作用域，fun(x)函数结束时
　           ２）对象的别名被显式删除， del  x
　           ３）对象的别名被赋值给了其他对象， x = 67
　           ４）对象从容器中移除， mylist.remove(x)
　           ５）容器对象本身被销毁， del  mylist
        
        2.内存池管理
        python本身提供一个非对象级内存分配管理系统，pymalloc，想申请的内存小于256字节由该系统分配
        否则交给操作系统malloc分配内存。
        设计该内存分配管理系统的目的是，
        1）python经常会申请小块内存且不是为了创建对象，频繁的分配和释放内存（操作系统在用户态和核心态之间转换）会影响执行效率
        2）python对象之间不共享内存池，分配又释放大量整数，缓存这些整数的内存不会被分配给另一种对象，比如list或浮点数
        
        3.垃圾回收
        
        1. gc检查引用计数，0直接清除，返回内存给内存池而不是操作系统
        2. 如果循环引用则交给循环垃圾回收器计算可达性分析
            python的循环垃圾回收可达性分析
            1. 收集所有容器对象（循环回收只针对容器对象，其他对象不会产生循环引用）
            2. 复制每一个容器对象的引用计数，即为gc_ref，a对象则为gc_ref_a
            3. 遍历容器找到它正在引用的对象即b，将gc_ref_b减1，检查所有的容器对象
            4. 如果最终gc_ref为0， 则证明该容器对象靠循环引用存活，故进行内存回收
        -- 查找和销毁过程繁琐，使用分代回收策略可以有效改善性能，jvm也是类似的分级说法
        
        
        3. 频繁垃圾回收将会影响效率，python在运行过程中记录分配对象和取消对象的次数，差值大于某个 阈值 启动垃圾回收
        python的gc本身也采用分代回收策略
        4. 分代回收 - 存活时间长的对象gc扫描的频率降低
        从年轻到年老为0，1，2三代
        新对象为0代， 每经历一次垃圾回收存活进入下一代
        回收器启动必定扫描0代，一定扫描次数后扫描0和1代，再到达一定次数全代扫描
        gc包的set_threshold(100,10,10)，100为垃圾开始回收的阈值， 第一个10代表扫描10次0代扫描一次0和1代，每10次0和1扫描后全代扫描
        
        ps： java中也有新生代扫描和全代扫描等概念，从减少老对象的扫描频率来说，确实可以实现分代垃圾回收的理念
        

'''




















